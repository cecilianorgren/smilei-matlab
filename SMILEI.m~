 classdef SMILEI
  %TSeries Load SMILEI simulation data
  %   Does not contain the data, but loads it in an easily accesible manner
  %
  %   SM = SMILEI(h5FilePath,nameListFilePath)
  %   Bx = SM.Bx; % Bx is a (nt x nx x ny) matrix
  %   B = SM.B; % structure with 3 (nt x nx x ny) matrices  
  
  properties (Access = protected) % can only be set from within the class (?)
    % Data can be arbitrary size, so the class contains a pointer to the 
    % data file and each time loads the data with. This is actualy really
    % bad, because it removes all the advantages of having class-specific
    % functions that easily acecsses the data and performs operarations. 
    file_
    namelist_
    info_
    fields_
    iteration_
    twpe_
    twci_
    gridsize_ % this should not be here, just put the grid instead, and use a function to get the size, but I haven't read the namelist yet
    grid_
    wpewce_ = [];
    mime_ = [];
    coordinateSystem_ = '';
  end
  
  properties (Dependent = true)
    file
    namelist
    info
    fields
    iteration
    twpe
    twci
    wpewce
    mime    
    gridsize
    grid
    coordinateSystem
  end
  
  properties (Constant = true, Hidden = true)
    MAX_TENSOR_ORDER = 2;
    BASIS = {'xyz','xzy'}; % in order to use, need to define transformations between these
    BASIS_NAMES = {'smilei','michael'};
  end
  
  %properties (SetAccess = protected)
  %  representation % can be related to basis
  %end
  
  properties
    userData = []; % anything can be added here
  end
  
  methods
    function obj = SMILEI(h5filePath,nameListFilePath)
      if exist('nameListFilePath','var') && not(isempty(nameListFilePath))
        [wpewce,mime,dxyz] = read_filelist(nameListFilePath);
        obj.wpewce_ = wpewce;
        obj.mime_ = mime;
      end
      
      obj.info = h5info(h5filePath);
      obj.file = h5filePath; 
      obj.iteration = get_iterations(obj);
      %obj.twci = get_iterations(obj);
      obj.twpe = get_twpe(obj);
      obj.fields_ = get_fields(obj);
      obj.gridsize_ = get_gridsize(obj);
      %obj.t_ = get_time(h5filePath);
      
      
    
    %  obj.fullDim_ = cell(ndims(data)-1,1); % time should not be included -> -1
    %  obj.representation = cell(ndims(data)-1,1); iDim = 1; % time should not be included -> -1
    end
    
    function [varargout] = subsref(obj,idx)
      %SUBSREF handle indexing
      switch idx(1).type
        % Use the built-in subsref for dot notation
        case '.'
          [varargout{1:nargout}] = builtin('subsref',obj,idx);
        case '()'
          tmpEpoch = builtin('subsref',obj.time,idx(1));
          obj.t_ = tmpEpoch;
          idxTmp = repmat({':'}, ndims(obj.data), 1);
          idxTmp(1) = idx(1).subs;
          obj.data_ = obj.data_(idxTmp{:});
          if numel(idx) > 1
            obj = builtin('subsref',obj,idx(2:end));
          end
          [varargout{1:nargout}] = obj;
        case '{}'
          error('irf:TSeries:subsref',...
            'Not a supported subscripted reference')
      end
    end
    
    function [wpewce,memi,dxyz] = read_namelist(filepath)
      
    end
    function value = get.coordinateSystem(obj)
      value = obj.coordinateSystem_;
    end
    
    %function value = get.data(obj)
    %  value = obj.data_;
    %end
    
    function value = length(obj)
      value = numel(obj.iteration);
    end
   
    function value = basis(obj)
      value = obj.BASIS{obj.tensorBasis_};
    end
    
    function out = get_twpe(obj)
      fileInfo = obj.info_;
      nOutput = numel(fileInfo.Groups.Groups);

      for iOutput = 1:nOutput
        time(iOutput) = fileInfo.Groups.Groups(iOutput).Attributes(1).Value;
      end
      out = time;
    end
    function out = get_iterations(obj)
      fileInfo = obj.info_;
      nOutput = numel(fileInfo.Groups.Groups);
      for iOutput = 1:nOutput
        str = fileInfo.Groups.Groups(iOutput).Name;
        split_str = strsplit(str,'/');
        iterations(iOutput) = str2num(split_str{3});
      end

      out = iterations;  
    end
    function out = get_fields(obj)
      fileInfo = obj.info;
      % fields structure is the same for all times
      out = {fileInfo.Groups(1).Groups(1).Datasets.Name};
    end
    function out = get_gridsize(obj)
      fileInfo = obj.info_;
      out = fileInfo.Groups(1).Groups(1).Datasets(1).Dataspace.Size;
    end
    %Components
    function f = Bx(obj)
      % get Bx
      f = get_field(obj,'Bx');
    end
    function f = By(obj)
      %access Y component
      [y,ok] = getComponent(obj,'y'); if ~ok, error('cannot get Y'), end
    end
    function f = Bz(obj)
      %access Z component
      [y,ok] = getComponent(obj,'z'); if ~ok, error('cannot get Z'), end
    end
    
    function obj = set.coordinateSystem(obj,value)
      if obj.tensorOrder_ < 1 
        error('irf:TSeries:setcoordinateSystem:badInputs',...
          'coordinateSystem can only be set for a tensor')
      end
      if ~ischar(value)
        error('irf:TSeries:setcoordinateSystem:badInputs',...
          'expecting string input')
      end
      obj.coordinateSystem_ = value;
    end
    
    function obj = set.info(obj,value)
      obj.info_ = value;
    end
    function obj = set.file(obj,value)
      obj.file_ = value;
    end
    function obj = set.namelist(obj,value)
      obj.namelist_ = value;
    end
    function obj = set.fields(obj,value)
      obj.fields_ = value;
    end
    function obj = set.iteration(obj,value)
      obj.iteration_ = value;
    end
    function obj = set.twpe(obj,value)
      obj.twpe_ = value;
    end
    function obj = set.twci(obj,value)
      obj.twci_ = value;
    end
    function obj = set.gridsize(obj,value)
      obj.gridsize_ = value;
    end
    function obj = set.grid(obj,value)
      obj.grid_ = value;
    end
    
    function value = get.info(obj)
      value = obj.info_;
    end
    function value = get.file(obj)
      value = obj.file_;
    end
    function value = get.namelist(obj)
      value = obj.namelist_;
    end
    function value = get.fields(obj)
      value = obj.fields_;
    end   
    function value = get.iteration(obj)
      value = obj.iteration_;
    end 
    function value = get.twpe(obj)
      value = obj.twpe_;
    end
    function value = get.twci(obj)
      value = obj.twci_;
    end
    function value = get.gridsize(obj)
      value = obj.gridsize_;
    end
    function value = get.grid(obj)
      value = obj.grid_;
    end            
    
    
    
      

  end
  
  methods (Access=protected)
    function out = get_field(obj,field)
      % get iterations
      iterations = obj.iteration;
      nIter = obj.length;
      % initialize matrix
      data = nan([nIter,obj.gridsize]);
      for iIter = 1:nIter
        data(iIter) = 
      end
    end
    
    function Ts = changeBasis(obj, flag)
      % Tranform from one coordinate system to another and return new
      % TimeSeries.
      % flag: = 'xyz>rlp' - Cartesian XYZ to spherical latitude
      %         'rlp>xyz' - Spherical latitude to cartesian XYZ
      %         'xyz>rpz' - Cartesian XYZ to cylindrical
      %         'rpz>xyz' - Cylidrical to cartesian XYZ
      %         'xyz>rtp' - Cartesian XYZ to spherical colatitude
      %         'rtp>xyz' - Spherical colatitude to cartesian XYZ
      %         'rtp>rlp' - Spherical colatitude to spherical latitude
      %         'rlp>rtp' - Spherical latitude to colatitude
      switch lower(flag)
        case 'xyz>rlp'
          [phi, lambda, r] = cart2sph(obj.x.data, obj.y.data, obj.z.data);
          Ts = TSeries(obj.time, [r, lambda, phi], 'vec_rlp');
        case 'rlp>xyz'
          [x, y, z] = sph2cart(obj.phi.data, obj.lambda.data, obj.r.data);
          Ts = TSeries(obj.time, [x, y, z], 'vec_xyz');
        case 'xyz>rpz'
          [phi, r, z] = cart2pol(obj.x.data, obj.y.data, obj.z.data);
          Ts = TSeries(obj.time, [r, phi, z], 'vec_rpz');
        case 'rpz>xyz'
          [x, y, z] = pol2cart(obj.phi.data, obj.r.data, obj.z.data);
          Ts = TSeries(obj.time, [x, y, z], 'vec_xyz');
        case 'xyz>rtp'
          [phi, lambda, r] = cart2sph(obj.x.data, obj.y.data, obj.z.data);
          theta = pi/2 - lambda;
          Ts = TSeries(obj.time, [r, theta, phi], 'vec_rtp');
        case 'rtp>xyz'
          lambda = pi/2 - obj.theta.data;
          [x, y, z] = sph2cart(obj.phi.data, lambda, obj.r.data);
          Ts = TSeries(obj.time, [x, y, z], 'vec_xyz');
        case 'rtp>rlp'
          lambda = pi/2 - obj.theta.data;
          Ts = TSeries(obj.time, [obj.r.data,lambda,obj.phi.data],'vec_rlp');
        case 'rlp>rtp'
          theta = pi/2 - obj.lambda.data;
          Ts = TSeries(obj.time, [obj.r.data,theta,obj.phi.data],'vec_rtp');
        case 'xy>rp'
          [phi, r] = cart2pol(obj.x.data, obj.y.data);
          Ts = TSeries(obj.time, [r, phi], 'vec_rp');
        case 'rp>xy'
          [x, y] = pol2cart(obj.phi.data, obj.r.data);
          Ts = TSeries(obj.time, [x, y], 'vec_xy');
        otherwise
          errStr='Invalid transformation'; error(errStr);
      end
    end
  end
  
end

